////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Spin-up with script
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"

#include <inttypes.h>

////////////////////////////////////////////////////////////////////////////////////////////////////
// Local data


/// @addtogroup g_spinup
/// @{

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Spin-up with script.
///
/// This function repeats a previous spin-up with different seed vector and generators.
/// To do so, the function needs a spin-up script, which is generated by @ref spinupStandardBasis.
/// See also @ref spinupscripts "Spin-Up Scripts".
///
/// The result is a matrix having as many rows as the script.

Matrix_t* spinupWithScript(const Matrix_t* seed, const MatRep_t* rep, const IntMatrix_t* script)
{
   imatValidate(MTX_HERE, script);
   if (script->noc != 2) {
      mtxAbort(MTX_HERE, "Invalid script");
   }
   matValidate(MTX_HERE, seed);
   mrValidate(MTX_HERE, rep);
   if (seed->noc != rep->Gen[0]->noc || seed->field != rep->Gen[0]->field) {
      mtxAbort(MTX_HERE,
         "Seed (%" PRIu32 "/GF%" PRIu32 ") not compatible with"
         " representation (%" PRIu32 "/GF%" PRIu32 ")",
         seed->noc, seed->field, rep->Gen[0]->noc, rep->Gen[0]->field);
   }

   ffSetField(seed->field);
   const uint32_t* op = (const uint32_t*) script->data;
   Matrix_t* basis = matAlloc(ffOrder, script->nor, seed->noc);
   for (int i = 0; i < script->nor; ++i) {
      uint32_t vecno = op[2 * i];
      uint32_t vecgen = op[2 * i + 1];
      PTR vec = matGetPtr(basis, i);
      if (vecgen == MTX_NVAL) {
         if (vecno < 1 || vecno > seed->nor) {
            mtxAbort(MTX_HERE, "Seed vector number (%d) out of range (%d)", vecno, seed->nor);
         }
         else {
            ffCopyRow(vec, matGetPtr(seed, vecno - 1), seed->noc);
         }
      }
      else {
         if (vecno < 0 || vecno >= i) {
            mtxAbort(MTX_HERE, "Invalid source vector %d at position %d", vecno, i);
         }
         else if (vecgen < 0 || vecgen >= rep->NGen) {
            mtxAbort(MTX_HERE, "Invalid generator number %d at position %d", vecgen, i);
         }
         ffMapRow(vec, matGetPtr(basis, vecno), rep->Gen[vecgen]->data, seed->noc, seed->noc);
      }
   }
   return basis;
}
    
////////////////////////////////////////////////////////////////////////////////////////////////////

/* Convert a spin-up script from 2.3 format.

   The MeatAxe version 2.3 uses 1-based indexes for both generators and vectors, seed 
   vectors have gen=0 and vec is the 1-based seed vector number.
   Starting with version 2.4, generator and vector indexes are 0-based,
   seed vectors have gen = -1 and vec is the 1-based(!) seed vector number.
*/

int ConvertSpinUpScript(IntMatrix_t *script)
{
    int k;
    int32_t *op = script->data;

    if (script->nor == 0 || op[1] < 0)
	return 0;

    for (k = 0; k < script->nor; ++k)
    {
	if (op[2*k+1] == 0)
	{
	    /* Seed vector: keep vector number, set gen=-1 */
	    op[2*k+1] = -1;
	}
	else
	{
	    /* Image vector: decrement vec and gen */
	    --op[2*k];
	    --op[2*k+1];
	}
    }
    return 1;

}

/// @}

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
