////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Spin-up with script
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
// Local data


/// @addtogroup spinup
/// @{

////////////////////////////////////////////////////////////////////////////////////////////////////

static int ArgsAreValid(const Matrix_t *seed, const MatRep_t *rep, const IntMatrix_t *script)
{
    imatValidate(MTX_HERE, script);
    if (script->Noc != 2)
	mtxAbort(MTX_HERE,"Invalid script");
    matValidate(MTX_HERE, seed);
    if (!mrIsValid(rep) || rep->NGen <= 0)
    {
	mtxAbort(MTX_HERE,"Invalid representation");
	return 0;
    }
    if (seed->Noc != rep->Gen[0]->Noc || seed->Field != rep->Gen[0]->Field)
    {
	mtxAbort(MTX_HERE,"seed and rep: %s",MTX_ERR_INCOMPAT);
	return 0;
    }
    return 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Spin-up with script.
/// This function repeats a previous spin-up with different seed vector and generators.
/// To do so, the function needs a spin-up script, which is generated by SpinUp().
/// The result is a matrix having as many rows as the script.
/// @param seed Matrix with seed vectors.
/// @param rep Pointer to a MatRep_t structure with generators.
/// @param script Pointer to the spinup script.
/// @return Span of the seed vector(s) under the action of the generators, or 0 on error.

Matrix_t *SpinUpWithScript(const Matrix_t *seed, const MatRep_t *rep, const IntMatrix_t *script)
{
    if (!ArgsAreValid(seed,rep,script))
    {
	mtxAbort(MTX_HERE,"Invalid arguments");
	return NULL;
    }

    /* Spin up
       ------- */
    ffSetField(seed->Field);
    const int32_t *op = script->Data;
    Matrix_t *basis = matAlloc(ffOrder,script->Nor,seed->Noc);
    for (int i = 0; i < script->Nor; ++i)
    {
    	int vecno = (int) op[2 * i];
	int vecgen = (int) op[2 * i + 1];
	PTR vec = matGetPtr(basis,i);
	if (vecgen < 0)
	{
	    if (vecno < 1 || vecno > seed->Nor)
	    {
	    	mtxAbort(MTX_HERE,"Seed vector number (%d) out of range (%d)",
		    vecno,seed->Nor);
	    }
            else {
               ffCopyRow(vec,matGetPtr(seed,vecno - 1),seed->Noc);
            }
	}
	else
	{
	    if (vecno < 0 || vecno >= i)
	    	mtxAbort(MTX_HERE,"Invalid source vector %d at position %d",vecno,i);
	    else if (vecgen < 0 || vecgen >= rep->NGen)
	    {
	    	mtxAbort(MTX_HERE,"Invalid generator number %d at position %d",
		    vecgen,i);
	    }
	    ffMapRow(matGetPtr(basis,vecno),rep->Gen[vecgen]->Data,seed->Noc,seed->Noc,vec);
	}
    }
    return basis;
}
    
////////////////////////////////////////////////////////////////////////////////////////////////////

/* Convert a spin-up script from 2.3 format.

   The MeatAxe version 2.3 uses 1-based indexes for both generators and vectors, seed 
   vectors have gen=0 and vec is the 1-based seed vector number.
   Starting with version 2.4, generator and vector indexes are 0-based,
   seed vectors have gen = -1 and vec is the 1-based(!) seed vector number.
*/

int ConvertSpinUpScript(IntMatrix_t *script)
{
    int k;
    int32_t *op = script->Data;

    if (script->Nor == 0 || op[1] < 0)
	return 0;

    for (k = 0; k < script->Nor; ++k)
    {
	if (op[2*k+1] == 0)
	{
	    /* Seed vector: keep vector number, set gen=-1 */
	    op[2*k+1] = -1;
	}
	else
	{
	    /* Image vector: decrement vec and gen */
	    --op[2*k];
	    --op[2*k+1];
	}
    }
    return 1;

}

/// @}

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
