////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Compare vector spaces
////////////////////////////////////////////////////////////////////////////////////////////////////


#include "meataxe.h"


////////////////////////////////////////////////////////////////////////////////////////////////////
/// @addtosection algo
/// @{

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Vector space incidence relation.
/// This function compares two vector spaces $U,V\in\GF{q}^n$ and returns $1$,
/// if $U\leq V$.
/// The spaces to compare are given as matrices where the rows of |sub| 
/// (linearly) generate $U$ and the rows of |space| generate $V$.
/// Thus, |sub| and |space| must be matrices over the same field and with the same
/// number of columns. Also, |space| must be in full echelon form while 
/// there is no further restriction on |sub|.
///
/// In normal mode, |ngen| is 0. Then, the rows of |sub| are checked one-by-one
/// to see if they are in the span of the rows of |space|. If this test passes
/// for each row of |sub|, the return value is 1, otherwise it is 0. 
/// There is no special return value for the cases $U=V$ or $U>V$.
///
/// If |ngen| is different from zero, the function assumes that $U$ is 
/// generated by the first |ngen| rows, and only this number of rows are
/// checked. For example, $U$ may be a cyclic submodule, 
/// which is generated from a single vector under the action of an algebra. 
/// Then, one only needs to check if the generating vector, which 
/// is supposed to be the first row of |sub|, is contained in $V$.
///
/// @param sub Generating set for the first space, U.
/// @param space Pointer to a basis for the second space, V.
/// @param ngen Number of vectors in |sub| to consider.
/// @return 1 if Uâ‰¤V$, 0 otherwise, -1 on error.

int IsSubspace(const Matrix_t *sub, const Matrix_t *space, int ngen)
{
    long nvec, spcdim, i;
    PTR tmp, y;

    /* Check the arguments
       ------------------- */
    matValidate(MTX_HERE, sub);
    matValidate(MTX_HERE, space);
    if (sub->field != space->field || sub->noc != space->noc)
    {
	mtxAbort(MTX_HERE,"%s",MTX_ERR_INCOMPAT);
	return -1;
    }
    if (space->pivotTable == NULL)
    {
	mtxAbort(MTX_HERE,"space: %s",MTX_ERR_NOTECH);
	return -1;
    }

    /* Decide how many vectors from <sub> we shall check
       ------------------------------------------------- */
    ffSetField(space->field);
    spcdim = space->nor;
    nvec = sub->nor;
    if (ngen > 0 && ngen < nvec)
	nvec = ngen;

    /* Allocate workspace 
       ------------------ */
    tmp = ffAlloc(1, space->noc);
    if (tmp == NULL)
    {	
	mtxAbort(MTX_HERE,"Cannot allocate workspace");
	return -1;
    }

    /* Check if vectors from <sub> are in the span of <space>
       ------------------------------------------------------ */
    for (i = nvec, y = sub->data; i > 0; --i, ffStepPtr(&y, space->noc))
    {
	FEL f;
	ffCopyRow(tmp,y, space->noc);
	ffCleanRow(tmp,space->data,spcdim,space->noc, space->pivotTable);
        if (ffFindPivot(tmp,&f, space->noc) != MTX_NVAL) 
	    break;
    }

    /* Clean up and return the result
       ------------------------------ */
    sysFree(tmp);
    return (i <= 0);
}

/// @}
// vim:fileencoding=utf8:sw=3:ts=8:et:cin
