////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Spin-up
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"
#include <string.h>

/// @defgroup spinup Spin-Up and Split
/// @{
/// @details
/// Given a matrix representation and a seed vector v, the spin-up algorithm
/// calculates the submodule generated by the seed vector, i.e., the smallest 
/// subspace containing v which is invariant under the generators.
/// SpinUp() can handle multiple seed vectors, search for cyclic vectors
/// generating the whole space, and generate seed vectors as linear combinations
/// of a given basis.
///
/// <b>Spin-up scripts</b>
/// When spinning up a seed vector, you can record the operations performed
/// by the algorithm in a spin-up script. This script can then be fed into
/// SpinUpWithScript() to repeat the procedure with a different seed vector 
/// and different generators.
///
/// <b>Standard basis</b>
/// Normally, the basis vectors computed during the spin-up process are chosen
/// randomly. However, the spin-up algorithm can be used in "standard basis" mode.
/// In this mode, the result is invariant under a change of basis.
/// More precisely, if a given seed vector v and generators g<sub>1</sub>,...g<sub>n</sub>
/// produce the basis (b<sub>1</sub>,...b_<sub>m</sub>), and A is a nonsingular matrix,
/// then vA and A<sup>-1</sup>g<sub>1</sub>A,...A<sup>-1</sup>g<sub>n</sub>A produce the basis
/// (b<sub>1</sub>A,...b<sub>m</sub>A).
///
/// <b>Splitting a representation</b>
/// If a proper invariant subspace U<V has been found for a matrix representation M,
/// the restriction of M to U as well as the representation on V/U can be calculated.
/// This is called splitting the representation. The basis for V/U is chosen randomly.

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @class SpinUpInfo_t
/// Spin-up Parameters.
/// The SpinUpInfo_t data structure is used to pass additional parameters
/// to the spin-up algorithm, and to return extended results to the caller.
/// @c Result is set by SpinUp() to report the success of the spin-up.
/// Possible values are 0 (successful), 1 (not found), and -1 (error).

////////////////////////////////////////////////////////////////////////////////////////////////////
// Local data

/// Internal state for spin up.
typedef struct {
   // user data
   const Matrix_t* seed;
   const MatRep_t* rep;
   int nPerms;
   Perm_t *perms;                       // NULL for matrix representation
   int flags;
   IntMatrix_t** script;
   uint32_t maxSubspaceDimension;
   int result;

   // internal data
   uint32_t Dim;		// Dimension of the whole space
   uint32_t *Piv;		// Pivot table
   Matrix_t *Span;		// Span
   int SpanDim;			// Dimension of the span
   int NGen;			// Number of generators 
   const Matrix_t **Gen;		// Generators
   const Perm_t **GenP;		// Generators (permutation mode)
   Matrix_t *StdSpan;	        // Span
   int32_t *ops;
} SpinupContext_t;

#define OPVEC(ctx,i) ctx->ops[2*(i)]
#define OPGEN(ctx,i) ctx->ops[2*(i)+1]


////////////////////////////////////////////////////////////////////////////////////////////////////

/// This function spins up the next seed vector.
/// @param seed The seed vector.
/// @param seedno The seed vector number.
/// @return 0 = success, 1 = no success, -1 = error

static int Spin1(SpinupContext_t* ctx, PTR seed, int seedno)
{
   int igen;        // Generator to apply next
   PTR get;         // Vector to map
   PTR put;         // New vectors go here
   PTR stdget, stdput;
   FEL f;
   int iget;
   uint32_t num_tries = 0;

   const uint32_t maxdim =
      ctx->maxSubspaceDimension > 0 ? ctx->maxSubspaceDimension + 1 : ctx->Dim + 1;

   // If we are not in 'combine' mode, start with an empty space.
   // In 'combine' mode, keep what has been found so far.
   if ((ctx->flags & SF_MODE_MASK) != SF_COMBINE) {
      ctx->SpanDim = 0;
   }

   // Initialize <get> and <put> to point to the first free row in <Span>
   get = matGetPtr(ctx->Span, ctx->SpanDim);
   iget = ctx->SpanDim;
   put = get;
   if (ctx->flags & SF_STD) {
      stdget = matGetPtr(ctx->StdSpan, ctx->SpanDim);
      stdput = stdget;
   }

   // Copy the seed vector to <put>, extending the pivot table
   ffCopyRow(put, seed, ctx->Span->noc);
   ffCleanRow(put, ctx->Span->data, ctx->SpanDim, ctx->Span->noc, ctx->Piv);
   if (ctx->ops != NULL) {
      OPVEC(ctx, ctx->SpanDim) = seedno;
      OPGEN(ctx, ctx->SpanDim) = -1;    // it's a seed vector
   }
   if ((ctx->Piv[ctx->SpanDim] = ffFindPivot(put, &f, ctx->Span->noc)) != MTX_NVAL) {
      ++ctx->SpanDim;
      ffStepPtr(&put, ctx->Dim);
      if (ctx->flags & SF_STD) {
         ffCopyRow(stdput, seed, ctx->Span->noc);
         ffStepPtr(&stdput, ctx->Dim);
      }
   }

   // Spin up
   igen = 0;
   while (get != put && ctx->SpanDim < ctx->Dim && ctx->SpanDim < maxdim && ctx->NGen > 0) {
      // Map the current vector using the current generator.
      if (ctx->flags & SF_STD) {
         if (ctx->Gen != NULL) {
            ffMapRow(stdput, stdget, ctx->Gen[igen]->data, ctx->Dim, ctx->Dim);
         }
         else {
            ffPermRow(stdput, stdget, ctx->GenP[igen]->data, ctx->Dim);
         }
         ffCopyRow(put, stdput, ctx->Dim);
      }
      else {
         if (ctx->Gen != NULL) {
            ffMapRow(put, get, ctx->Gen[igen]->data, ctx->Dim, ctx->Dim);
         }
         else {
            ffPermRow(put, get, ctx->GenP[igen]->data, ctx->Dim);
         }
      }
      if (ctx->ops != NULL) {
         OPVEC(ctx, ctx->SpanDim) = iget;
         OPGEN(ctx, ctx->SpanDim) = igen;
      }

      // If this was the last generator, continue with the next vector.
      if (++igen >= ctx->NGen) {
         ++num_tries;
         igen = 0;
         ffStepPtr(&get, ctx->Dim);
         ffStepPtr(&stdget, ctx->Dim);
         ++iget;
      }

      // Clean the image with the existing basis.
      ffCleanRow(put, ctx->Span->data, ctx->SpanDim, ctx->Span->noc, ctx->Piv);
      if ((ctx->Piv[ctx->SpanDim] = ffFindPivot(put, &f, ctx->Span->noc)) != MTX_NVAL) {
         // Ne basis vector
         num_tries = 0;
         ++ctx->SpanDim;
         ffStepPtr(&put, ctx->Dim);
         ffStepPtr(&stdput, ctx->Dim);
      }
   }

   // Calculate return code.
   //MTX_LOG2("SpinUp(): sub=%d, quot=%d",SpanDim,Dim-SpanDim);
   switch (ctx->flags & SF_MODE_MASK) {
      case SF_SUB:
         return (ctx->SpanDim > 0 && ctx->SpanDim < ctx->Dim && ctx->SpanDim < maxdim) ?
                0 : 1;
      case SF_CYCLIC:
      case SF_COMBINE:
         return ctx->SpanDim < ctx->Dim ? 1 : 0;
   }
   mtxAbort(MTX_HERE, "Invalid search mode %d", ctx->flags & SF_MODE_MASK);
   return -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Check arguments (common to matrix and permutation mode)

static void CheckArgs0(const Matrix_t *seed, int flags, SpinUpInfo_t* info)
{
    matValidate(MTX_HERE, seed);
    if (seed->nor < 1) 
	mtxAbort(MTX_HERE,"Empty seed space");
    if (flags == -1)
	mtxAbort(MTX_HERE,"Invalid flags");
    if (info) {
       // Max + 1 must not overflow
       MTX_ASSERT(info->MaxSubspaceDimension < 0xFFFFFFFF);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void CheckArgsM(const Matrix_t *seed, const MatRep_t *rep, int flags, SpinUpInfo_t* info)
{
    CheckArgs0(seed, flags, info);
    mrValidate(MTX_HERE, rep);
    if (rep->NGen > 0) {
       if (seed->noc != rep->Gen[0]->nor || seed->field != rep->Gen[0]->field)
          mtxAbort(MTX_HERE, "Seed vector(s) are not compatible with representation");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Common initialization for matrix and permutation mode

static void Init0(SpinupContext_t* ctx)
{
    int ws_size;
    ffSetField(ctx->seed->field);
    ctx->Dim = ctx->seed->noc;

    // Allocate workspace, assuming the worst case.
    if (ctx->maxSubspaceDimension > 0)
    	ws_size = ctx->maxSubspaceDimension + 1;
    else
	ws_size = ctx->Dim + 1;
    ctx->Span = matAlloc(ctx->seed->field,ws_size,ctx->Dim);

    ctx->SpanDim = 0;
    ctx->Piv = NALLOC(uint32_t,ctx->Dim+2);
    if (ctx->script != NULL)
    {
       // Reuse existing script if possible
	if (*ctx->script != NULL && ((*ctx->script)->noc != 2 || (*ctx->script)->nor < ctx->Dim + 1))
	{
	    imatFree(*ctx->script);
	    *ctx->script = NULL;
	}
	if (*ctx->script == NULL)
	    *ctx->script = imatAlloc(ctx->Dim+1,2);
	ctx->ops = (*ctx->script)->data;
    }
    else
	ctx->ops = NULL;

    if (ctx->flags & SF_STD)
	ctx->StdSpan = matAlloc(ctx->seed->field,ctx->Dim+1,ctx->Dim);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void CheckArgsP(
   const Matrix_t* seed,
   int ngen,
   const Perm_t** gen,
   int flags,
   SpinUpInfo_t* info)
{
   CheckArgs0(seed, flags, info);
   if (ngen <= 0) {
      mtxAbort(MTX_HERE, "Invalid number of generators (%d)", ngen);
   }
   for (int i = 0; i < ngen; ++i) {
      permValidate(MTX_HERE, gen[i]);
      if (gen[i]->degree != seed->noc) {
         mtxAbort(MTX_HERE, "Gen=%d, seed=%d: %s", gen[i]->degree, seed->noc, MTX_ERR_INCOMPAT);
      }
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static SpinupContext_t* CreateContext0(
      const Matrix_t* seed,
      int flags,
      IntMatrix_t** script,
      SpinUpInfo_t* info)
{
   SpinupContext_t* ctx = ALLOC(SpinupContext_t);
   ctx->seed = seed;
   ctx->flags = flags;
   ctx->script = script;
   if (info) {
      ctx->maxSubspaceDimension = info->MaxSubspaceDimension;
      ctx->result = info->Result;
   }
   return ctx;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static SpinupContext_t* CreateContextM(
      const Matrix_t* seed,
      const MatRep_t* rep,
      int flags,
      IntMatrix_t** script,
      SpinUpInfo_t* info)
{
   CheckArgsM(seed, rep, flags, info);
   SpinupContext_t* ctx = CreateContext0(seed, flags, script, info);
   Init0(ctx);
   ctx->rep = rep;
   ctx->Gen =  (const Matrix_t **) ctx->rep->Gen;
   ctx->GenP = NULL;
   ctx->NGen = rep->NGen;
   return ctx;
}

static SpinupContext_t* CreateContextP(
      const Matrix_t* seed,
      int nPerms,
      const Perm_t** perms,
      int flags,
      IntMatrix_t** script,
      SpinUpInfo_t* info)
{
   CheckArgsP(seed, nPerms, perms, flags, info);
   SpinupContext_t* ctx = CreateContext0(seed, flags, script, info);
   Init0(ctx);
   ctx->rep = NULL;
   ctx->Gen = NULL;
   ctx->GenP = perms,
   ctx->NGen = nPerms;
   return ctx;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void DestroyContext(SpinupContext_t* ctx)
{
   if (ctx->Span != NULL) {
      matFree(ctx->Span);
      ctx->Span = NULL;
   }
   memset(ctx, 0, sizeof(*ctx));
   sysFree(ctx);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Spin up
/// @return 0 = Ok, 1 = Not found, -1 = Error

static int DoSpinup(SpinupContext_t* ctx)
{
    long n;
    int result;
    PTR seed;

    switch (ctx->flags & SF_SEED_MASK)
    {
    	case SF_FIRST:
	    /* Try the first seed vector only
	       ------------------------------ */
	    return Spin1(ctx, ctx->seed->data,1);

    	case SF_EACH:
	    /* Try each seed vector until successful
	       ------------------------------------- */
	    for (seed = ctx->seed->data, n = 1; n <= ctx->seed->nor; ffStepPtr(&seed, ctx->Dim),++n)
	    {
	    	if (Spin1(ctx,seed,n) == 0)
		    return 0;
	    }
	    return 1;

    	case SF_MAKE:
	    /* Try each 1-dimensional subspace until successfull
	       ------------------------------------------------- */
	    if ((seed = ffAlloc(1, ctx->Dim)) == NULL) 
	    {
		mtxAbort(MTX_HERE,"Cannot allocate seed vector");
		return -1;
	    }
	    result = 1;
	    for (n = 0; result == 1 && (n = MakeSeedVector(ctx->seed,n,seed)) > 0; )
	    {
	    	if (Spin1(ctx, seed,n) == 0)
		    result = 0;
	    }
	    sysFree(seed);
	    return result;
   
	default:
	    mtxAbort(MTX_HERE,"Invalid seed mode");
    }
    return -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void DoIt(SpinupContext_t* ctx)
{
   ctx->result = DoSpinup(ctx);
   if (ctx->result < 0)
      mtxAbort(MTX_HERE,"Spin-up failed"); // TODO: remove (fail in DoSpinup)

    // Adjust the result size.
    if (ctx->flags & SF_STD)
    {
	matFree(ctx->Span);
	ctx->Span = ctx->StdSpan;
    }
    else
    {
	matEchelonize(ctx->Span);
    }
    ctx->Span->nor = ctx->SpanDim;
    ctx->Span->data = (PTR) sysRealloc(ctx->Span->data,ffSize(ctx->SpanDim, ctx->seed->noc));
    if (ctx->script != NULL)
    {
	(*ctx->script)->data = NREALLOC((*ctx->script)->data,int32_t,2 * ctx->SpanDim);
	(*ctx->script)->nor = ctx->SpanDim;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Spin up.
/// This function calculates the submodule generated by one or more "seed"
/// vectors under the action of a set of matrices. @a seed must be a matrix
/// with the same number of columns as the generators and any number of rows.
/// Of course, all matrices, generators and seed, must be over the same field.
///
/// The spinup mode and various options are controlled by two arguments,
/// @a flags and @a info. @a flags must be a combination of the following
/// values:
/// - @c SF_FIRST: Only the first row of @a seed is taken as seed vector.
/// - @c SF_EACH: Each row of @a seed is taken as seed vector.
/// - @c SF_MAKE: One vector from each 1-dimensional subspace of the row space of @a seed is taken
///      as seed vector.
/// - @c SF_SUB: Find a submodule: spin up seed vectors one-by-one until a seed vector generates a
///      proper submodule.
/// - @c SF_CYCLIC: Find a cyclic vector: spin up vectors one-by-one until a seed vector generates
///      the whole space.
/// - @c SF_COMBINE: Calculate the submodule generated by the set of all seed vectors. This ist
///      typically used with @c SF_EACH to calculate the submodule generate by the row space of
///      @a seed.
/// - @c SF_STD: Create the standard basis. This increases both computation time and memory usage.
///
/// The seed modes, @c SF_FIRST, @c SF_EACH and @c SF_MAKE, and the search modes, @c SF_SUB,
/// @c SF_CYCLIC, @c SF_COMBINE, are mutually exclusive. If, in mode @c SF_SUB or @c SF_CYCLIC, no
/// seed vector generates a proper submodule or the whole space, respectively, this is not
/// considered an error, and the return value is not @c NULL. The rows of the matrix returned by
/// SpinUp() always form a basis of an invariant subspace, but you must examine the number of rows
/// of that matrix to find out if it is a proper subspace, or null, or the whole space.
///
/// The subspace returned by SpinUp() is always in echelon form, if @c SF_STD is not used. With
/// @c SF_STD however, the subspace is not necessarily in echelon form.
///
/// SpinUp() can record the operations that led to the invariant subspace in a "spin-up script".
/// You can use the script as input to SpinUpWithScript() to repeat the spin-up with a different
/// seed vector. Typically, a spin-up script is created together with @em SF_STD, and then used to
/// reconstruct the standard basis in a different representation.
/// In order to create a spin-up script, @a script must point to a variable of type IntMatrix_t*.
/// This variable must either be 0 or contain a valid pointer. In the second case, the buffer
/// pointed to by @a script is first deallocated before a new script is created. After SpinUp()
/// returns, the variable contains a pointer to the script. If no spinup script is needed, pass NULL
/// as 4th parameter.
///
/// The format of the spinup script is a matrix with 2 columns and one row for each basis vector.
/// A row (n,-1) means that the corresponding basis vector is the n-th seed vector. Seed vector
/// numbers start from 1. An entry (n,g) with g≥0 means that the corresponding basis vector was
/// obtained by multiplying the n-th basis vector by the g-th generator. Basis vector number and
/// generator number start from 0.
///
/// Additional parameters can be passed via the @a info argument. To be compatible with future
/// versions of SpinUpInfo_t, you should always initialize the parameter structure with
/// SpinUpinfoInit().
///
/// @param seed Matrix with seed vectors.
/// @param rep Pointer to a MatRep_t structure with generators.
/// @param flags Flags, a combination of @c SF_XXXX constants (see description).
/// @param script Pointer to a variable where the spinup script will be stored (see description).
///    May be NULL if the script is not needed.
/// @param info Pointer to a data structure with additional parameters, or NULL.
/// @return Span of the seed vector(s) under the action of the generators, or NULL on error.


Matrix_t* SpinUp(
   const Matrix_t* seed,
   const MatRep_t* rep,
   int flags,
   IntMatrix_t** script,
   SpinUpInfo_t* info)
{
   SpinupContext_t* ctx = CreateContextM(seed, rep, flags, script, info);
   DoIt(ctx);
   Matrix_t* result = ctx->Span;
   ctx->Span = NULL;
   if (info) {
      info->Result = ctx->result;
   }
   DestroyContext(ctx);
   return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Spin Up With Permutations.
/// This function works like Spinup() but expects permutations instead of matrices
/// for the generators.

Matrix_t* SpinUpWithPermutations(
   const Matrix_t* seed, int ngen,
   const Perm_t** gen, int flags, IntMatrix_t** script, SpinUpInfo_t* info)
{
   SpinupContext_t* ctx = CreateContextP(seed, ngen, gen, flags, script, info);
   DoIt(ctx);
   Matrix_t* result = ctx->Span;
   ctx->Span = NULL;
   if (info) {
      info->Result = ctx->result;
   }
   DestroyContext(ctx);
   return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Initialize spin-up parameters.
/// @param info Pointer to parameter structure.

void SpinUpInfoInit(SpinUpInfo_t* info)
{
   memset(info, 0, sizeof(*info));
}

/// @}
// vim:fileencoding=utf8:sw=3:ts=8:et:cin
