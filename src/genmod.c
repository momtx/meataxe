////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Calculates submodule basis 
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"
#include <string.h>
#include <stdlib.h>

static MatRep_t *Rep;           // Generators for the algebra
static Matrix_t *mountains;     // Genrators for all mountains
static uint32_t nmount;         // Number of mountains
static int submoduleNumber;     // Number of the submodule to generate
static BitString_t *bs;         // Corresponding bit string (read from .sub file)
static int opt_m = 0;           // Option -m used
static LatInfo_t* LI;          // Data from .cfinfo file
static const char *ModuleName = NULL;

static MtxApplicationInfo_t AppInfo = { 
"genmod", "Make submodule",
"SYNTAX"
"    genmod [-QVm] <Name> <Number>\n"
"\n"
"ARGUMENTS\n"
"    <Name> .................. Module name\n"
"    <Number> ................ Submodule number\n"
"\n"
"OPTIONS\n"
MTX_COMMON_OPTIONS_DESCRIPTION
"    -m ...................... Make mountain (works after mkinc)\n"
"\n"
"FILES\n"
"    <Name>.sub .............. I  Submodule information (generated by mksub)\n"
"    <Name>.v ................ I  Mountains\n"
"    <Name>.s<Number> ........ O  The result (without -m)\n"
"    <Name>.m<Number> .........O  The result (with -m)\n"
};

static MtxApplication_t *App = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////

static void init(int argc, char **argv)
{
    App = appAlloc(&AppInfo,argc,argv);
    opt_m = appGetOption(App,"-m --mountain");
    appGetArguments(App,2,2);
    ModuleName = App->argV[0];
    submoduleNumber = atoi(App->argV[1]);
    LI = latLoad(ModuleName);

    // Read the generators and mountains.
    Rep = mrLoad(ModuleName,LI->NGen);
    mountains = matLoad(strEprintf("%s.v",LI->baseName));
    nmount = mountains->nor;
    MTX_LOGD("%lu mountains", (unsigned long)nmount);
    
    // Read the bit string from xxx.sub or set up the bit string
    // to contain only the requested mountain (-m)
    if (opt_m)
    {
	bs = bsAlloc(nmount);
	bsSet(bs,submoduleNumber);
    }
    else
    {
    	MtxFile_t* f = mfOpen(strEprintf("%s.sub",LI->baseName),"rb");
        for (int k = 0; k < submoduleNumber; ++k) {
           bsSkip(f);
        }
        bs = bsRead(f);
	mfClose(f);

        MTX_XLOGD(msg) {
	    sbAppend(msg, "Mountains: ");
	    for (uint32_t i = 0; i < nmount; ++i) {
	    	if (bsTest(bs,i)) {
                   sbPrintf(msg, "%lu ", (unsigned long)i);
                }
            }
    	}
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void sp()
{
    PTR p;

    Matrix_t* m = matAlloc(ffOrder,nmount,Rep->Gen[0]->noc);
    p = m->data;
    for (uint32_t i = 0; i < nmount; ++i)
    {
	if (bsTest(bs,i))
	{
	    PTR q = ffGetPtr(mountains->data,i, Rep->Gen[0]->noc);
	    ffCopyRow(p,q, Rep->Gen[0]->noc);
	    ffStepPtr(&p, Rep->Gen[0]->noc);
	}
    }
    matEchelonize(m);
    MTX_LOGI("Seed space has dimension %lu",(unsigned long)m->nor);
    // OLD: Matrix_t* subsp = SpinUp(m,Rep,SF_EACH|SF_COMBINE,NULL,NULL);
    Matrix_t* subsp = spinup(m,Rep);
    matFree(m);
    MTX_LOGI("Submodule has dimension %lu", (unsigned long) subsp->nor);
    char* fn = strEprintf("%s.%c%d",LI->baseName,opt_m ? 'm' : 's',submoduleNumber);
    matSave(subsp,fn);
    matFree(subsp);
    MTX_LOGI("Module written to %s",fn);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void cleanup()
{
   bsFree(bs);
   matFree(mountains);
   latDestroy(LI);
   mrFree(Rep);
   appFree(App);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{
    init(argc, argv);
    sp();
    cleanup();
    return 0;
}



/**
@page prog_genmod genmod - Make Submodule

@section genmod_syntax Command Line
<pre>
genmod @em Options [-m] @em Name @em Number
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts
@par -m
  Make mountain (works after @ref prog_pwkond "pwkond").
@par @em Name
  Module name.
@par @em Number
  Submodule number.

@section genmod_inp Input Files
@par @em Name.sub
  Submodule information.
@par @em Name.v
  Mountains.

@section genmod_out Output Files
@par Name.sNumber, Name.mNumber
  The result (see decription).

@section genmod_desc Description
This program makes a submodule, i.e., it takes the mountains
contained in that submodule and spins them up. The result
is written to <em>Name</em>.s<em>Number</em>. The program assumes that
the submodule structure has been calculated with @ref prog_mksub "mksub".

If the -m option is used, @em Number is treated as the
number of a mountain. This mountain is generated and written
to  <em>Name</em>.m<em>Number</em>.

**/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
