////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Calculates submodule basis 
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"
#include <string.h>
#include <stdlib.h>



/* ------------------------------------------------------------------
   Global data
   ------------------------------------------------------------------ */


MatRep_t *Rep;			/* Generators for the algebra */
Matrix_t *mountains;		/* Genrators for all mountains */
int nmount;			/* Number of mountains */
int modnum;
BitString_t *bs;		/* Bit string read from .sub file */
int opt_m = 0;			/* Option -m used */
static Lat_Info LI;		/* Data from .cfinfo file */
static const char *ModuleName = NULL;

static MtxApplicationInfo_t AppInfo = { 
"genmod", "Make submodule",
"SYNTAX"
"    genmod [-QVm] <Name> <Number>\n"
"\n"
"ARGUMENTS\n"
"    <Name> .................. Module name\n"
"    <Number> ................ Submodule number\n"
"\n"
"OPTIONS\n"
MTX_COMMON_OPTIONS_DESCRIPTION
"    -m ...................... Make mountain (works after mkinc)\n"
"\n"
"FILES\n"
"    <Name>.sub .............. I  Submodule information (generated by mksub)\n"
"    <Name>.v ................ I  Mountains\n"
"    <Name>.s<Number> ........ O  The result (without -m)\n"
"    <Name>.m<Number> .........O  The result (with -m)\n"
};

static MtxApplication_t *App = NULL;






/* -----------------------------------------------------------------
   init() - Read generators and mountains
   ----------------------------------------------------------------- */

static int Init(int argc, char **argv)
{
    char fn[200];
    FILE *f;
    int i;

    App = appAlloc(&AppInfo,argc,argv);
    opt_m = appGetOption(App,"-m --mountain");
    appGetArguments(App,2,2);
    ModuleName = App->ArgV[0];
    modnum = atoi(App->ArgV[1]);
    latReadInfo(&LI,ModuleName);

    /* Read the generators and mountains.
       ---------------------------------- */
    Rep = mrLoad(ModuleName,LI.NGen);
    mountains = matLoad(strcat(strcpy(fn,LI.BaseName),".v"));
    nmount = mountains->Nor;
    MESSAGE(1,("%d mountains\n",nmount));
    

    /* Read the bit string from xxx.sub or set up the bit string
       to contain only the requested mountain (-m)
      ------------------------ --------------------------------- */
    if (opt_m)
    {
	bs = bsAlloc(nmount);
	bsSet(bs,modnum);
    }
    else
    {
    	f = sysFopen(strcat(strcpy(fn,LI.BaseName),".sub"),"rb");
    	if (f == NULL)
	    mtxAbort(MTX_HERE,"CANNOT OPEN .sub FILE");
	bs = bsAlloc(nmount);
    	sysFseek(f,modnum * (12 + (bs->size + 7) / 8));	/* HACK: !!! */
	bsFree(bs);
    	bs = bsRead(f);
    	if (MSG1)
    	{
	    printf("Mountains: ");
	    for (i = 0; i < nmount; ++i)
	    	if (bsTest(bs,i)) printf("%d ",i);
	    printf("\n");
    	}
	fclose(f);
    }

    return 0;
}



/* -----------------------------------------------------------------
   sp()
   ----------------------------------------------------------------- */

static void sp()

{
    int i;
    Matrix_t *m, *subsp;
    PTR p;
    char fn[200];

    m = matAlloc(ffOrder,nmount,Rep->Gen[0]->Noc);
    p = m->Data;
    for (i = 0; i < nmount; ++i)
    {
	if (bsTest(bs,i))
	{
	    PTR q = ffGetPtr(mountains->Data,i, Rep->Gen[0]->Noc);
	    ffCopyRow(p,q, Rep->Gen[0]->Noc);
	    ffStepPtr(&p, Rep->Gen[0]->Noc);
	}
    }
    matEchelonize(m);
    MESSAGE(0,("Seed space has dimension %d\n",m->Nor));
    subsp = SpinUp(m,Rep,SF_EACH|SF_COMBINE,NULL,NULL);
    MESSAGE(0,("Submodule has dimension %d\n",subsp->Nor));
    sprintf(fn,"%s.%c%d",LI.BaseName,opt_m ? 'm' : 's',modnum);
    matSave(subsp,fn);
    MESSAGE(0,("Module written to `%s'\n",fn));
}


/* -----------------------------------------------------------------
   main()
   ----------------------------------------------------------------- */

int main(int argc, char *argv[])

{
    if (Init(argc, argv) != 0)
    {
	mtxAbort(MTX_HERE,"Initialization failed");
	return -1;
    }


    sp();
    appFree(App);
    return 0;
}



/**
@page prog_genmod genmod - Make Submodule

@section genmod_syntax Command Line
<pre>
genmod @em Options [-m] @em Name @em Number
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts
@par -m
  Make mountain (works after @ref prog_pwkond "pwkond").
@par @em Name
  Module name.
@par @em Number
  Submodule number.

@section genmod_inp Input Files
@par @em Name.sub
  Submodule information.
@par @em Name.v
  Mountains.

@section genmod_out Output Files
@par Name.sNumber, Name.mNumber
  The result (see decription).

@section genmod_desc Description
This program makes a submodule, i.e., it takes the mountains
contained in that submodule and spins them up. The result
is written to <em>Name</em>.s<em>Number</em>. The program assumes that
the submodule structure has been calculated with @ref prog_mksub "mksub".

If the -m option is used, @em Number is treated as the
number of a mountain. This mountain is generated and written
to  <em>Name</em>.m<em>Number</em>.

**/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
