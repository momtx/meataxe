////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Calculate a representative for each cyclic submodule of the condensed modules.
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"

#include <inttypes.h>
#include <stdlib.h>
#include <string.h>

static MtxApplicationInfo_t AppInfo = {
   "mkcycl", "Find Cyclic Submodules",
   "SYNTAX\n"
   "    mkcycl [<Options>] <Name>\n"
   "\n"
   "ARGUMENTS\n"
   "    <Name> .................. Name of the representation\n"
   "\n"
   "OPTIONS\n"
   MTX_COMMON_OPTIONS_DESCRIPTION
   "    -G ...................... GAP output (implies -Q)\n"
   "\n"
   "FILES\n"
   "    <Name>.cfinfo ........... I Constituent info file\n"
   "    <Name><Cf>.{1,2...}k .... I Generators on condensed modules\n"
   "    <Name><Cf>.np ........... I Condensed peak words\n"
   "    <Name><Cf>.v ............ O Cyclic submodules\n"
};

static MtxApplication_t* App = NULL;
static int opt_G = 0;
static uint32_t nCyclic;        // Number of cyclic submodules found
Matrix_t* cyclic[MAXCYCL];      // Bases for cyclic submodules
LatInfo_t* LI;                  // Data from .cfinfo file

////////////////////////////////////////////////////////////////////////////////////////////////////

static void init(int argc, char** argv)
{
   App = appAlloc(&AppInfo, argc, argv);
   opt_G = appGetOption(App, "-G --gap");
   appGetArguments(App, 1, 1);
   MTX_LOGI("Start mkcycl - Find cyclic submodules");
   LI = latLoad(App->argV[0]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Spins up one seed vector and adds the resulting submodule to the set of cyclic submodules.

static void spinupVector(Matrix_t* seed, MatRep_t* rep)
{
   Matrix_t* sub = spinup(seed, rep);
   for (uint32_t i = 0; i < nCyclic; ++i) {
      int issub = IsSubspace(sub, cyclic[i], 1);
      if (issub == -1) {
         mtxAbort(MTX_HERE, "Subspace comparison failed");
         return;
      }
      if (issub && sub->nor == cyclic[i]->nor) {
         matFree(sub);          // Module already in list
         return;
      }
   }
   if (nCyclic >= MAXCYCL) {
      mtxAbort(MTX_HERE, "Too many cyclic submodules (maximum = %d)", MAXCYCL);
      return;
   }
   cyclic[nCyclic] = sub;
   ++nCyclic;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// Writes generating vectors for all cyclic submodules to the output file («module»«constituent».v).

static void writeResult(int cf, uint32_t condDim)
{
   char fn[200];
   Matrix_t* result;

   result = matAlloc(ffOrder, nCyclic, condDim);
   for (uint32_t i = 0; i < nCyclic; ++i) {
      MTX_ASSERT(cyclic[i]->noc == condDim);
      matCopyRegion(result, i, 0, cyclic[i], 0, 0, 1, condDim);
   }
   sprintf(fn, "%s%s.v", LI->BaseName, latCfName(LI, cf));
   MTX_LOGD("Writing %s", fn);
   matSave(result, fn);
   matFree(result);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// This function is called once for each constituent. It finds all cyclic submodules in the
// corresponding condensed module. After return, the global variable «cyclic» contains all
// (distinct) cyclic submodules found.
//
// Generating vectors for the cyclic submodules are written to the file «module»«constituent».v,
// e.g., test44a).
//
// Note:
// Strictly speaking we find all cyclic submodules which are invariant under the condensed
// generators. The algebra generated by the condensed generators may not be the full condensed
// algebra. For this reason we add the condensed peak word to the set of generators.

static void findCyclicSubmodules(int cf)
{
   char fn[200];

   // Read the generators and the condensed peak words
   sprintf(fn, "%s%s.%%dk", LI->BaseName, latCfName(LI, cf));
   MTX_LOGD("Loading generators for %s%s", LI->BaseName, latCfName(LI, cf));
   MatRep_t* rep = mrLoad(fn, LI->NGen);
   sprintf(fn, "%s%s.np", LI->BaseName, latCfName(LI, cf));
   mrAddGenerator(rep, matLoad(fn), 0);

   // Spin up all seed vectors
   const uint32_t condDim = rep->Gen[0]->nor;  // Dimension of the condensed module
   Matrix_t* seed = matAlloc(ffOrder, 1, condDim);
   Matrix_t* seed_basis = matId(ffOrder, condDim);
   nCyclic = 0;
   unsigned long count = 0;
   uint32_t vec_no = 0;
   uint64_t progressTimer = 0;
   while (svgMakeNext(seed->data, &vec_no, seed_basis) == 0) {
      ++count;
      if (sysTimeout(&progressTimer, 5)) {
         MTX_LOG2("  %lu vectors, %" PRIu32 " submodules", count, nCyclic);
      }
      spinupVector(seed, rep);
   }

   // Write the result and clean up
   MTX_LOGI("%s%s: %d cyclic submodule%s (%lu vectors tried)",
      LI->BaseName, latCfName(LI, cf), nCyclic, nCyclic == 1 ? " " : "s", count);
   writeResult(cf, condDim);
   matFree(seed);
   matFree(seed_basis);

   // Clean up
   for (uint32_t i = 0; i < nCyclic; ++i) {
      matFree(cyclic[i]);
   }
   mrFree(rep);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void cleanup()
{
   latDestroy(LI);
   appFree(App);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
   init(argc, argv);
   for (int i = 0; i < LI->nCf; ++i) {
      findCyclicSubmodules(i);
   }
   cleanup();
   return 0;
}

/**
@page prog_mkcycl mkcycl - Find Cyclic Subspaces

@section mkcycl_syntax Command Line
<pre>
mkcycl @em Options [-G] @em Name
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts
@par -G
  Produce output in GAP format.
@par @em Name
  Name of the representation.

@section mkcycl_inp Input Files
@par @em Name.cfinfo
  Constituent info file.
@par @em NameCf.1k, @em NameCf.2k, ...
  Generators on condensed modules.
@par @em NameCf.np
  Condensed peak words

@section mkcycl_out Output Files
@par @em NameCf.v
  Cyclic submodules.

@section mkcycl_desc Description
The MKCYCL program is part of the @ref sec_progs_lattice "Submodule Lattice Package".
It is invoked after @ref prog_pwkond "pwkond" has calculated the
condensation with respect to the peak words. MKCYCL calculates, for each
condensed module, its 1-dimensional subspaces. The output is a list of vectors
(in matrix form) for each irreducible constituent, which generate all cyclic
submodules. For example, if "X10a" is the constituent's name, the list of
vectors is written to "X10a.v".

@section mkcycl_impl Implementation Details
@b mkcycl uses a very simple approach: it spins up every vector in the 
condensed module (avoiding scalar multiples, though), and maintains a
list of all cyclic submodules found. As the dimension of the condensed
module grows, the number of vectors to spin up quickly becomes very large. 
This poses an upper limit on the dimension of condensed modules, i.e., on 
the multiplicity of irreducible constituents. Over GF(2), for example, a
16-dimensional condensed module requires about 20 hours of CPU time
on a standard workstation.

A second limit concerns the number of cyclic submodules. Usually there
are much less cyclic submodules than 1-spaces. Sometimes, however, it 
may happen that the peak word found in the second step is "bad" in the 
sense that the condensed generators commute. In such a case one finds 
a large number of cyclic submodules and the following steps will probably 
take too much time. For this reason, the @ref prog_pwkond "pwkond" program
has an option to exclude one or more specified peak words from the search.
So, if the peak word turns out to be "bad", you can try another one.
**/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
