////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Calculate a representative for each cyclic submodule of the condensed modules.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include "meataxe.h"
#include <string.h>
#include <stdlib.h>

static MtxApplicationInfo_t AppInfo = { 
"mkcycl", "Find Cyclic Submodules",
"SYNTAX\n"
"    mkcycl [<Options>] <Name>\n"
"\n"
"ARGUMENTS\n"
"    <Name> .................. Name of the representation\n"
"\n"
"OPTIONS\n"
MTX_COMMON_OPTIONS_DESCRIPTION
"    -G ...................... GAP output (implies -Q)\n"
"\n"
"FILES\n"
"    <Name>.cfinfo ........... I Constituent info file\n"
"    <Name><Cf>.{1,2...}k .... I Generators on condensed modules\n"
"    <Name><Cf>.np ........... I Condensed peak words\n"
"    <Name><Cf>.v ............ O Cyclic submodules\n"
};

static MtxApplication_t *App = NULL;
static int opt_G = 0;
static MatRep_t *Rep;           // The representation
int NCyclic;                    // Number of cyclic submodules found
Matrix_t *Cyclic[MAXCYCL];      // List of cyclic submodules
LatInfo_t* LI;                 // Data from .cfinfo file

////////////////////////////////////////////////////////////////////////////////////////////////////

static void init(int argc, char **argv)
{
    App = appAlloc(&AppInfo,argc,argv);
    opt_G = appGetOption(App,"-G --gap");
    appGetArguments(App,1,1);
    MTX_LOGI("Start mkcycl - Find cyclic submodules");
    LI = latLoad(App->argV[0]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// This function spins up one seed vector and compares the resulting module with the list of
/// cyclic submodules found so far. If the module is new, it is added to the list.

static void Spinup(Matrix_t *seed)
{
    Matrix_t *sub;
    int i;

    sub = SpinUp(seed,Rep,SF_FIRST|SF_SUB,NULL,NULL);
    for (i = 0; i < NCyclic; ++i)
    {
	int issub = IsSubspace(sub,Cyclic[i],1);
	if (issub == -1)
	{
	    mtxAbort(MTX_HERE,"Subspace comparison failed");
	    return;
	}
	if (issub && sub->nor == Cyclic[i]->nor)
	{
	    matFree(sub);	// Module already in list
	    return;
	}
    }
    if (NCyclic >= MAXCYCL)
    {
	mtxAbort(MTX_HERE,"Too many cyclic submodules (maximum = %d)",MAXCYCL);
	return;
    }
    Cyclic[NCyclic] = sub;
    ++NCyclic;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// Write the output file
// This function collects the generating vectors of all syclic submodules
// into a single matrix and write this matrix to a file.

void WriteResult(int cf, uint32_t cond_dim)
{
    int i;
    char fn[200];
    Matrix_t *result;

    result = matAlloc(ffOrder,NCyclic,cond_dim);
    for (i = 0; i < NCyclic; ++i)
	matCopyRegion(result,i,0,Cyclic[i],0,0,1,Cyclic[i]->noc);
    sprintf(fn,"%s%s.v",LI->BaseName,latCfName(LI,cf));
    MTX_LOGD("Writing %s",fn);
    matSave(result,fn);
    matFree(result);
}

////////////////////////////////////////////////////////////////////////////////////////////////////


// FindCyclic() - Find cyclic submodules
//
// This function is called once for each constituent. It finds all cyclic
// submodules in the corresponding condensed module, i.e., in the module
// that was condensed with a peak word for this constituent.
//
// The function uses the seed vector generator to get one vector from each
// one-dimensional subspace. It spins up the seed vectors and stores the 
// distinct submodules obtained in the global variable <Cyclic>.
//
// Generating vectors for the cyclic sumodules are written to the file
// xxxx.v where xxxx is the constituent name (e.g., test44a).
//
// Note: 
// Strictly speaking we find all cyclic submodules which are invariant 
// under the condensed generators. The algebra generated by the condensed
// generators may not be the full condensed algebra. For this reason we
// add the kondensed peak word to the set of generators.

void FindCyclic(int cf)
{
    Matrix_t *seed;
    Matrix_t *seed_basis;
    char fn[200];
    long vec_no;		// Seed vector number
    int count;			// Number of vectors tried
    int i;

    // Read the generators and the condensed peak words
    sprintf(fn,"%s%s.%%dk",LI->BaseName,latCfName(LI,cf));
    MTX_LOGD("Loading generators for %s%s",LI->BaseName,latCfName(LI,cf));
    Rep = mrLoad(fn,LI->NGen);
    sprintf(fn,"%s%s.np",LI->BaseName,latCfName(LI,cf));
    mrAddGenerator(Rep,matLoad(fn),0);

    // Spin up all seed vectors
    const uint32_t cond_dim = Rep->Gen[0]->nor; // Dimension of the condensed module
    seed = matAlloc(ffOrder,1,cond_dim);
    seed_basis = matId(ffOrder,cond_dim);
    NCyclic = 0;
    count = 0;
    vec_no = 0;
    while ((vec_no = MakeSeedVector(seed_basis,vec_no,seed->data)) >= 0)
    {
	++count;
	if (count % 100 == 0)
	    MTX_LOG2("  %d vectors, %d submodules",count,NCyclic);
	Spinup(seed);
    }

    // Write the result and clean up
    MTX_LOGI("%s%s: %d cyclic submodule%s (%d vectors tried)",
	LI->BaseName,latCfName(LI,cf),NCyclic,NCyclic == 1 ? " " : "s",
	count);
    WriteResult(cf,cond_dim);
    matFree(seed);
    matFree(seed_basis);

    // Clean up
    for (i = 0; i < NCyclic; ++i)
	matFree(Cyclic[i]);
    mrFree(Rep);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void cleanup()
{
   latDestroy(LI);
   appFree(App);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{
    init(argc, argv);
    for (int i = 0; i < LI->nCf; ++i)
	FindCyclic(i);
    cleanup();
    return 0;
}

/**
@page prog_mkcycl mkcycl - Find Cyclic Subspaces

@section mkcycl_syntax Command Line
<pre>
mkcycl @em Options [-G] @em Name
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts
@par -G
  Produce output in GAP format.
@par @em Name
  Name of the representation.

@section mkcycl_inp Input Files
@par @em Name.cfinfo
  Constituent info file.
@par @em NameCf.1k, @em NameCf.2k, ...
  Generators on condensed modules.
@par @em NameCf.np
  Condensed peak words

@section mkcycl_out Output Files
@par @em NameCf.v
  Cyclic submodules.

@section mkcycl_desc Description
The MKCYCL program is part of the @ref sec_progs_lattice "Submodule Lattice Package".
It is invoked after @ref prog_pwkond "pwkond" has calculated the
condensation with respect to the peak words. MKCYCL calculates, for each
condensed module, its 1-dimensional subspaces. The output is a list of vectors
(in matrix form) for each irreducible constituent, which generate all cyclic
submodules. For example, if "X10a" is the constituent's name, the list of
vectors is written to "X10a.v".

@section mkcycl_impl Implementation Details
@b mkcycl uses a very simple approach: it spins up every vector in the 
condensed module (avoiding scalar multiples, though), and maintains a
list of all cyclic submodules found. As the dimension of the condensed
module grows, the number of vectors to spin up quickly becomes very large. 
This poses an upper limit on the dimension of condensed modules, i.e., on 
the multiplicity of irreducible constituents. Over GF(2), for example, a
16-dimensional condensed module requires about 20 hours of CPU time
on a standard workstation.

A second limit concerns the number of cyclic submodules. Usually there
are much less cyclic submodules than 1-spaces. Sometimes, however, it 
may happen that the peak word found in the second step is "bad" in the 
sense that the condensed generators commute. In such a case one finds 
a large number of cyclic submodules and the following steps will probably 
take too much time. For this reason, the @ref prog_pwkond "pwkond" program
has an option to exclude one or more specified peak words from the search.
So, if the peak word turns out to be "bad", you can try another one.
**/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
