////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Random orders.
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "meataxe.h"

#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>




/* ------------------------------------------------------------------
   Global data
   ------------------------------------------------------------------ */


static int opt_G = 0;
static int opt_s = 0;
static int Count = 0;
static int NGen = 0;
static void *Gen[MAXGEN];


static MtxApplicationInfo_t AppInfo = { 
"zro", "Random Orders", 
"SYNTAX\n"
"    zro [-GVQs] [-T <#Secs>] <Count> <Gen> ...\n"
"\n"
"OPTIONS\n"
MTX_COMMON_OPTIONS_DESCRIPTION
"    -G ...................... GAP output (implies -Q)\n"
"    -s ...................... Summary only\n"
"\n"
"ARGUMENTS\n"
"    <Count> ................. Number of orders to calculate\n"
"    <Gen> ................... Name of the representation\n"
};


static MtxApplication_t *App = NULL;


////////////////////////////////////////////////////////////////////////////////////////////////////

static void init(int argc, char **argv)
{

    App = appAlloc(&AppInfo,argc,argv);

    opt_G = appGetOption(App,"-G --gap");
    opt_s = appGetOption(App,"-s --summary");
    if (opt_G) MtxMessageLevel = -100;
    appGetArguments(App,2,MAXGEN+1);
    Count = atoi(App->argV[0]);
    if (Count < 1)
	mtxAbort(MTX_HERE,"Invalid count '%s' (try --help)",App->argV[0]);

    // Read the generators
    NGen = App->argC - 1;
    for (int i = 0; i < NGen; ++i)
    {
	Gen[i] = objLoad(App->argV[i+1]);
	if (i > 0 && !objCanMultiply(Gen[0],Gen[i]))
	{
	    mtxAbort(MTX_HERE,"%s and %s: %s",App->argV[1],App->argV[i+1],
		MTX_ERR_INCOMPAT);
	}
    }
}





#define MAXORDERS 10
long Order[MAXORDERS+1];
int CountTab[MAXORDERS+1];

static void RandomOrders()
{
    int n;
    void *m = NULL;

    m = objDup(Gen[0]);
    mtxRandomInit(0);
    if (opt_G)
	printf("MeatAxe.RandomOrders := [");
    for (n = 0; n < Count; ++n)
    {
	long o = objOrder(m);
	if (opt_s)
	{
	    int i;
	    for (i = 0; i < MAXORDERS && CountTab[i] > 0 && Order[i] != o; ++i);
	    if (i < MAXORDERS)
	    {
		Order[i] = o;
		++CountTab[i];
	    }
	}
	else
	{
	    if (n % 15 == 0)
		printf("\n    ");
	    printf("%4ld",o);
    	    if (opt_G && n < Count - 1) 
		printf(",");
	}
	objMul(m,Gen[mtxRandomInt(NGen)]);
    }
    if (opt_G)
	printf("];\n");
    else
    {
	if (opt_s)
	{
	    int i;

	    for (i = 0; i < MAXORDERS && CountTab[i] > 0; ++i) 
	    {
		int k;
		for (k = i + 1; k < MAXORDERS && CountTab[k] > 0; ++k)
		{
		    if (Order[i] > Order[k])
		    {
			long o = Order[i];
			int c = CountTab[i];
			Order[i] = Order[k];
			Order[k] = o;
			CountTab[i] = CountTab[k];
			CountTab[k] = c;
		    }
		}
	    }

	    printf("Order:");
	    for (i = 0; i < MAXORDERS && CountTab[i] > 0; ++i) 
		printf("%6ld",Order[i]);
	    printf("\nCount:");
	    for (i = 0; i < MAXORDERS && CountTab[i] > 0; ++i) 
		printf("%6d",CountTab[i]);
	    printf("\n");
	}
	else
	    printf("\n");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
    init(argc,argv);
    RandomOrders();
    appFree(App);
    return 0;
}

/**
@page prog_zro zro - Random Orders

@section zro_syntax Command Line
<pre>
zro [@em Options] [-Gs] @em Count @em Gen [@em Gen ...]
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts.
@par -G
  GAP output.
@par -s
  Summary output.
@par @em Count
  Number or orders to calculate.
@par @em Gen
  Generator.

@section zro_inp Input Files
@par @em Gen
  Generator (matrix or permutation).

@section zro_desc Description
@b zro calculates the order of @em Count random elements of the
group generated by a set of matrices or permutations. This information
can be helpful to find out which group is generated by a given set of
matrices or permutations.
*/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
