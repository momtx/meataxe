////////////////////////////////////////////////////////////////////////////////////////////////////
// C MeatAxe - Calculate the submodule lattice
////////////////////////////////////////////////////////////////////////////////////////////////////


#include "meataxe.h"
#include <string.h>
#include <stdlib.h>

#define O_MOUNTAINS		0x01
#define O_SUBMODULES		0x02
#define O_DOTTEDLINES		0x04
#define O_EXTFILES		0x08
#define O_RADICAL		0x10
#define O_SOCLE			0x20
#define O_INCIDENCES		0x40
#define O_ALL (O_MOUNTAINS|O_SUBMODULES|O_DOTTEDLINES|O_EXTFILES|\
	       O_RADICAL|O_SOCLE|O_INCIDENCES)


int opt_b = 0;			// -b option (blocks)
int opt_o = O_ALL;
int opt_G = 0;
int done[LAT_MAXCF];

int blockNumber;		// Number of current block
int blockSize;			// Block size
int blockMember[LAT_MAXCF];	// Block members (index in constituent list)

int firstm[LAT_MAXCF+1];	// First mountain per constituent
int firstdl[LAT_MAXCF+1];	// First dotted line per constituent


// Data read from input files
int xnmount = 0;		// Number of mountains
int xndotl = 0;			// Number of dotted lines
BitString_t *xsubof[MAXCYCL];	// Incidence matrix
BitString_t *xdotl[MAXDOTL];	// Dotted lines
long xmdim[MAXCYCL];		// Mountain dimensions
static Lat_Info LI;		// Data from .cfinfo file


// Data for current block
int bnmount;		        // Number of mountains in block
int bndotl;		        // Number of dotted-lines in block
long bmdim[MAXCYCL];            // Mountain dimensions
BitString_t *bsubof[MAXCYCL];   // Incidence matrix for block
BitString_t *bsupof[MAXCYCL];	// Transposed incidence matrix
BitString_t *bdotl[MAXDOTL];    // Dotted-lines for block
BitString_t *bdlspan[MAXDOTL];  // Closure of dotted-lines

/// @private
/// List of submodules found so far.
typedef struct MaxSubmodule {
      struct Submodule* sub;    // maximal submodule
      int isoType;              // type of factor module (index in constituents list)
} MaxSubmodule_t;

/// @private
typedef struct Submodule {
   struct Submodule* htNext;    // Links submodules with the same hash key
   BitString_t *bs;             // Mountains
   int isMountain;              // 1 for mountains, 0 otherwise.
   uint32_t dimension;
   MaxSubmodule_t* maxSubmodules; // List of maximal submodules, terminated with {NULL,0}
   int radicalLayer;            // Radical series layer (0=top) or -1 if not in radical series
   int socleLayer;              // Socle series layer (0=bottom) or -1 if not in socle series
   int generation;
   size_t seq;                  // reflects the order in which submodules were found
   size_t id;                   // index after topological sort
} Submodule_t;
int nsub = 0;			// Number of submodules
Submodule_t* sub[MAXNSUB];	// Submodules (linear list)

// Hash table for sub[]. Used to check efficiently whether a given module is already in the list.
static Submodule_t* hashTable[2048] = { 0 };
static const size_t HASH_SIZE = sizeof(hashTable) / sizeof(hashTable[0]);

// Range in sub[] occupied by the previous submodule generation.
int lastGenBegin = 0;		// Begin of last generation
int lastGenEnd;			// End of last generation 

int generation;			// Current generation number
int nadd;			// Number of calls to addSubmodule()
BitString_t *y;			// Temporary bit string

static MtxApplicationInfo_t AppInfo = { 
"mksub", "Find Submodules",
"\n"
"SYNTAX\n"
"    mksub [<Options>] <Name>\n"
"\n"
"ARGUMENTS\n"
"    <Name> .................. Name of the representation\n"
"\n"
"OPTIONS\n"
MTX_COMMON_OPTIONS_DESCRIPTION
"    -G ...................... GAP output (implies -Q)\n"
"    -b ...................... Find blocks\n"
"    -o <Fmt> ................ Output elements in <Fmt>\n"
"    -n <Fmt> ................ Exclude elements in <Fmt>\n"
"        <Fmt> is any combination of m (mountains), d (dotted lines),\n"
"        i (incidence matrix), e (.lat and .gra files), s (submodule list),\n"
"        r (radical series), and o (socle series).\n"
"\n"
"FILES\n"
"    <Name>.cfinfo ........... IO Constituent info file\n"
"    <Name>.inc .............. I  Incidence matrix generated by MKINC\n"
"    <Name>.dot .............. I  Dotted-lines generated by MKDOTL\n"
"    <Name>.mnt .............. I  Mountain dimensions\n"
"    <Name>.out .............. O  Submodule lattice\n"
"    <Name>.lat .............. O  Incidence matrix of the submodules (GAP)\n"
"    <Name>.gra .............. O  Submodule lattice for MKGRAPH\n"
"\n"
"    If -b is used, output files are produced for each block, and a\n"
"    block number is appended to the file names (e.g., `psl27.out.1').\n"
};


static MtxApplication_t *App = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////

static void init(const char *basename)
{	
    int i;
    char fn[40];

    latReadInfo(&LI,basename);
    
    // Read incidence matrix
    {
       MtxFile_t* f = mfOpen(strcat(strcpy(fn,LI.BaseName),".inc"),"r");
       uint32_t l;
       mfRead32(f, &l, 1);
       xnmount = (int) l;
       MTX_LOGD("Reading%s: %d mountain%s",fn,xnmount,xnmount == 1 ? "" : "s");
       if (xnmount > MAXCYCL) 
       {
          mtxAbort(MTX_HERE,"Too many mountains (%d, max=%d)",xnmount,MAXCYCL);
          return;
       }
       for (i = 0; i < xnmount; ++i)
       {
          if ((xsubof[i] = bsRead(f)) == NULL)
          {
             mtxAbort(MTX_HERE,"Error reading incidence matrix");
             return;
          }
          if (xsubof[i]->size != xnmount)
          {
             mtxAbort(MTX_HERE,"Invalid bit string");
             return;
          }
       }
       mfClose(f);
    }

    // Read dotted lines
    {
       MtxFile_t* f = mfOpen(strcat(strcpy(fn,LI.BaseName),".dot"),"rb");
       MTX_LOGD("Reading %s: ",fn);
       uint32_t l;
       mfRead32(f,&l,1);
       xndotl = (int) l;
       MTX_LOGD("%d dotted line%s",xndotl,xndotl == 1 ? "" : "s");
       if (xndotl > MAXDOTL) 
       {
          mtxAbort(MTX_HERE,"Too many dotted-lines (%d, max=%d)",xndotl,MAXDOTL);
          return;
       }
       for (i = 0; i < xndotl; ++i)
       {
          if ((xdotl[i] = bsRead(f)) == NULL)
          {
             mtxAbort(MTX_HERE,"Error reading dotted lines");
             return;
          }
       }
       mfClose(f);
    }
    y = bsAlloc(xnmount);

    // Read dimensions
    {
       FILE* f = sysFopen(strcat(strcpy(fn,LI.BaseName),".mnt"),"r");
       MTX_LOGD("Reading %s",fn);
       for (i = 0; i < xnmount; ++i)
       {
          long mno, mdim;
          if (fscanf(f,"%ld%ld",&mno,&mdim) != 2 || mno != i || mdim < 1)
          {
             mtxAbort(MTX_HERE,"Error in .mnt file");
             return;
          }
          xmdim[i] = mdim;
          while (fgetc(f) != '\n')	// Skip class
          {
             if (ferror(f) || feof(f))
             {
                mtxAbort(MTX_HERE,"Error in .mnt file");
                return;
             }
          }
       }
       fclose(f);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Determine the isomorphism type of a mountain.

static int isotype(int mnt)
{
    int m;
    for (m = 0; (mnt -= LI.Cf[blockMember[m]].nmount) >= 0; ++m);
    return blockMember[m];
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void sortBlock()
{
   MTX_LOGI("Sorting %lu submodules", (unsigned long) nsub);

   BitString_t* x;
   for (int i = 0; i < nsub; ++i) {
      static uint64_t progressTimer = 0;
      if (sysTimeout(&progressTimer, 5)) {
         MTX_LOGD("%lu/%lu...", (unsigned long) i, (unsigned long) nsub);
      }
      for (int k = i + 1; k < nsub; ++k) {
         if (bsIsSub(sub[k]->bs, sub[i]->bs)) {
            x = sub[i]->bs;
            sub[i]->bs = sub[k]->bs;
            sub[k]->bs = x;
         }
      }
   }

   for (size_t i = 0; i < nsub; ++i)
      sub[i]->id = i;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Calculate the radical series, socle series, and submodule dimensions.

void finishBlock()
{
   sortBlock();

   MTX_LOGI("Calculating maximal submodules");
   uint8_t* flag = NALLOC(uint8_t, nsub);   // 0=unknown, 1=maximal, 2=not maximal
   BitString_t* bs = bsAlloc(bnmount);

   // Calculate maximal submodules and submodule dimensions
   for (int i = 0; i < nsub; ++i) {
      int maxcount = 0;
      memset(flag, 0, (size_t) nsub);
      static uint64_t progressTimer = 0;
      if (sysTimeout(&progressTimer, 5)) {
         MTX_LOGD("%lu/%lu...", (unsigned long) i, (unsigned long) nsub);
      }

      // Find all maximal submodules
      for (int k = i; k > 0;) {
         --k;
         if (flag[k] != 0) { continue; }
         if (bsIsSub(sub[k]->bs, sub[i]->bs)) {
            flag[k] = 1;
            ++maxcount;
            for (size_t l = k; l > 0;) {
               --l;
               if (bsIsSub(sub[l]->bs, sub[k]->bs)) {
                  flag[l] = 2;
               }
            }
         }
      }
      sub[i]->isMountain = (maxcount == 1);

      // Build a list of maximal submodules and simple factors.
      sub[i]->maxSubmodules = NALLOC(MaxSubmodule_t, maxcount + 1);
      MaxSubmodule_t* lp = sub[i]->maxSubmodules;
      for (int k = 0; k < i; ++k) {
         if (flag[k] != 1) continue;
         MTX_ASSERT(lp < sub[i]->maxSubmodules + maxcount);
         lp->sub = sub[k];
         size_t l;
         for (l = 0; !bsTest(sub[i]->bs, l) || bsTest(sub[k]->bs, l); ++l) {}
         MTX_ASSERT(l < bnmount);
         lp->isoType = isotype((int)l);
         ++lp;
      }
      // Terminate list
      lp->sub = NULL;
      lp->isoType = 0;

      // Calculate submodule dimension. Since we are working from bottom to top,
      // the dimension of maximal submodules is already known.
      if (maxcount == 0) {
         sub[i]->dimension = 0;
      }
      else {
         const MaxSubmodule_t* max0 = sub[i]->maxSubmodules;
         sub[i]->dimension = max0->sub->dimension + LI.Cf[max0->isoType].dim;
      }
   }

   // Calculate the radical series
   if (opt_o & O_RADICAL) {
      MTX_LOGI("Calculating radical series");
      sub[nsub-1]->radicalLayer = 0;
      int layer = 1;
      for (int i = nsub - 1; i > 0;) {
         bsCopy(bs, sub[i]->bs);
         for (const MaxSubmodule_t* lp = sub[i]->maxSubmodules; lp && lp->sub != NULL; ++lp) {
            bsAnd(bs, lp->sub->bs);
         }
         for (i = nsub - 1; !bsIsSub(sub[i]->bs, bs); --i) {}
         sub[i]->radicalLayer = layer++;
      }
   }

   // Calculate the socle series
   if (opt_o & O_SOCLE) {
      MTX_LOGI("Calculating socle series");
      sub[nsub-1]->socleLayer = 0;
      int layer = 1;
      for (int i = 0; i < nsub - 1;) {
         // Find simple submodules
         memset(flag, 0, (size_t) nsub);
         for (int k = i + 1; k < nsub; ++k) {
            if (flag[k] != 0) { continue;}
            if (bsIsSub(sub[i]->bs, sub[k]->bs)) {
               int l;
               flag[k] = 1;
               for (l = k + 1; l < nsub; ++l) {
                  if (bsIsSub(sub[k]->bs, sub[l]->bs)) { flag[l] = 2;}}
            }
         }

         // Calculate the socle (sum of all simple submodules)
         bsCopy(bs, sub[i]->bs);
         for (int k = i; k < nsub; ++k) {
            if (flag[k] == 1) {
               bsOr(bs, sub[k]->bs);
            }
         }

         for (i = 0; i < nsub && !bsIsSub(bs, sub[i]->bs); ++i) {}
         MTX_ASSERT(i < nsub);
         sub[i]->socleLayer = layer++;
      }
   }

   sysFree(flag);
   bsFree(bs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Calculates a submodule candidate by adding one mountain (i) and taking the closure under the
/// dotted-lines relation.

static void extend(BitString_t *x, int i, int nextend)
{
    int k;
    int changed;

    bsOr(x,bsupof[i]);		// Add the mountain and its subspaces
    if (nextend) bsClear(x,i);	// Add the radical only

    // Make closure
    static char dlflag[MAXDOTL] = {0};
    memset(dlflag,0,sizeof(dlflag));
    for (changed = 1; changed; )
    {
	changed = 0;
        for (k = 0; k < bndotl; ++k)
        {
	    if (!dlflag[k] && bsIntersectionCount(x,bdotl[k]) >= 2)
	    {
	        bsOr(x,bdlspan[k]);
	        dlflag[k] = 1;
	        changed = 1;
	    }
	}
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

MtxFile_t* openOutputFile(char* name)
{
   char* fn = strEprintf(opt_b ? "%s%s.%d" : "%s%s", LI.BaseName, name, blockNumber);
   MTX_LOGD("Writing %s", fn);
   return mfOpen(fn, "wb");
}


FILE* openTextOutputFile(char* name)
{
   char* fn = strEprintf(opt_b ? "%s%s.%d" : "%s%s", LI.BaseName, name, blockNumber);
   MTX_LOGD("Writing %s", fn);
   return sysFopen(fn, "w");
}

////////////////////////////////////////////////////////////////////////////////////////////////////

#define NDIG(x) (x>99999?6:x>9999?5:x>999?4:x>99?3:x>9?2:1)

static int printbs(FILE *f, BitString_t *b)
{
    int k, k1, k2, len, flag;

    if (bnmount < 100)
    {
	for (k = 0; k < bnmount;  ++k)
	    fputc(bsTest(b,k) ? '+' : '.',f);
	len = bnmount;
    }
    else
    {
	len = k = 0;
	flag = 0;
	while (1)
	{
	    while (k < bnmount && !bsTest(b,k)) ++k;
	    if (k >= bnmount) 
		break;
	    k1 = k;
	    while (k < bnmount && bsTest(b,k)) ++k;
	    k2 = k-1;
	    if (flag)
	    {
		fputc(',',f);
		++len;
	    }
	    else
		flag = 1;
	    if (k2 > k1)
	    {
		fprintf(f,"%d-%d",k1,k2);
		len += NDIG(k1)+NDIG(k2)+1;
	    }
	    else
	    {
		fprintf(f,"%d",k1);
		len += NDIG(k1);
	    }
	}
    }
    return len;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Write output files for current block

void writeresult()
{
   int i, k;
   char tmp[100];
   BitString_t* b = bsAlloc(bnmount);

   MTX_LOGI("Finished, %d submodules found", nsub);
   FILE* f = openTextOutputFile(".out");

   // Write irreducible constituents
   fprintf(f, "Irreducibles:\n");
   fprintf(f, "    Type   Mult   SF   Mountains           Dotted lines\n");
   for (i = 0; i < blockSize; ++i) {
      sprintf(tmp, "%s", latCfName(&LI, blockMember[i]));
      fprintf(f, "    %-7s%-7ld%-5ld", tmp, LI.Cf[blockMember[i]].mult,
         LI.Cf[blockMember[i]].spl);
      sprintf(tmp, "%ld (%ld-%ld)", LI.Cf[blockMember[i]].nmount,
         (long) firstm[blockMember[i]],
         LI.Cf[blockMember[i]].nmount + firstm[blockMember[i]] - 1);
      fprintf(f, "%-20s", tmp);
      if (LI.Cf[blockMember[i]].ndotl > 0) {
         sprintf(tmp, "%ld (%ld-%ld)", LI.Cf[blockMember[i]].ndotl,
            (long) firstdl[blockMember[i]],
            LI.Cf[blockMember[i]].ndotl + firstdl[blockMember[i]] - 1);
      }
      else {
         sprintf(tmp, "0");
      }
      fprintf(f, "%-20s\n", tmp);
   }
   fprintf(f, "\n");

   // Write mountains
   if (opt_o & O_MOUNTAINS) {
      fprintf(f, "Mountains:\n");
      fprintf(f, "    No     Dim    Maximal Submountains\n");
      for (i = 0; i < bnmount; ++i) {
         fprintf(f, "    %-7d%-7ld", i, bmdim[i]);
         bsCopy(b, bsupof[i]);
         bsClear(b, i);
         for (k = 0; k < bnmount; ++k) {
            if (!bsTest(b, k)) { continue; }
            bsMinus(b, bsupof[k]);
            bsSet(b, k);
         }
         for (k = 0; k < bnmount; ++k) {
            if (bsTest(b, k)) { fprintf(f, "%d ", k); } }
         fprintf(f, "\n");
      }
      fprintf(f, "\n");
   }

   // Write incidence matrix
   if (opt_o & O_INCIDENCES) {
      fprintf(f, "Incidence matrix:\n");
      for (i = 0; i < bnmount; ++i) {
         fprintf(f, "    %3d: ", i);
         printbs(f, bsupof[i]);
         fprintf(f, "\n");
      }
      fprintf(f, "\n");
   }

   // Dotted lines
   if (opt_o & O_DOTTEDLINES) {
      fflush(stdout);
      fprintf(f, "Dotted lines:\n");
      for (i = 0; i < bndotl; ++i) {
         fprintf(f, "    %3d: ", i);
         printbs(f, bdotl[i]);
         fprintf(f, "\n");
      }
      fprintf(f, "\n");
   }

   // Submodule list
   if (opt_o & O_SUBMODULES) {
      fflush(stdout);
      MtxFile_t* g = openOutputFile(".sub");
      fprintf(f, "Submodules:\n");
      fprintf(f, "    No    Dim  Flags  Ident                           Max\n");
      for (i = 0; i < nsub; ++i) {
         fprintf(f, "    %-6d%-5lu", i, (unsigned long)sub[i]->dimension);
         fputc(sub[i]->isMountain ? 'M' : ' ', f);
         fputc(sub[i]->radicalLayer > 0 ? 'R' : ' ', f);
         fputc(sub[i]->socleLayer > 0 ? 'S' : ' ', f);
         fprintf(f, "    ");
         k = printbs(f, sub[i]->bs);
         for (; k < 30; ++k) {
            fputc(' ', f);
         }
         fprintf(f, "  ");
         for (MaxSubmodule_t* lp = sub[i]->maxSubmodules; lp && lp->sub; ++lp) {
            if (lp != sub[i]->maxSubmodules) { fputc(',', f); }
            fprintf(f, "%lu", (unsigned long) lp->sub->id);
         }
         fprintf(f, "\n");
         bsWrite(sub[i]->bs, g);
      }
      fprintf(f, "\n");
      mfClose(g);
   }

   // Radical series
   if (opt_o & O_RADICAL) {
      static int mult[LAT_MAXCF];
      BitString_t* rad = bsAlloc(bnmount);
      BitString_t* newrad = bsAlloc(bnmount);
      BitString_t* x = bsAlloc(bnmount);
      BitString_t* zero = bsAlloc(bnmount);

      fprintf(f, "Radical series:\n");
      for (i = 0; i < bnmount; ++i) {
         bsSet(rad, i);
      }
      bsClearAll(zero);
      long rdim = 0;
      for (i = 0, rdim = 0; i < LI.nCf; ++i) {
         rdim += LI.Cf[i].dim * LI.Cf[i].mult;
      }
      for (int layer = 1; bsCompare(rad, zero) != 0; ++layer) {
         MTX_ASSERT(rdim > 0);
         bsClearAll(x);
         bsClearAll(newrad);
         MTX_LOGD("Starting layer %d", layer);

         // Extend the zero module = x by all those mountains
         // which are contained in the radical and extend y
         for (i = 0; i < bnmount && bsCompare(rad, x); ++i) {
            if (bsTest(rad, i) && !(bsTest(x, i))) {
               extend(x, i, 0);
               extend(newrad, i, 1);
            }
         }

         // Find the irreducible factors in this layer
         memset(mult, 0, sizeof(mult));
         bsCopy(x, newrad);
         for (i = 0; i < bnmount && bsCompare(rad, x); ++i) {
            if (bsTest(rad, i) && !(bsTest(x, i))) {
               extend(x, i, 0);
               k = isotype(i);
               ++mult[k];
               rdim -= LI.Cf[k].dim;
            }
         }
         // TODO: add layer 0 (full module)
         // TODO: output module number for each layer
         fprintf(f, "    Layer %d: Dim=%-4ld  ", layer, rdim);
         for (i = 0; i < LI.nCf; ++i) {
            for (; mult[i] > 0; --mult[i]) {
               fprintf(f, "%s ", latCfName(&LI, i));
            }
         }
         fprintf(f, "\n");
         bsCopy(rad, newrad);
      }
      fprintf(f, "\n");
   }
   fclose(f);

   if ((opt_o & O_EXTFILES) && (opt_o & O_SUBMODULES)) {
      // Write the .lat file
      FILE* latFile = openTextOutputFile(".lat");
      fprintf(latFile, "MeatAxe.Lattice := [\n");
      for (i = 0; i < nsub; ++i) {
         fprintf(latFile, "[%lu,[", (unsigned long) sub[i]->dimension);
         k = 0;
         for (const MaxSubmodule_t* maxSub = sub[i]->maxSubmodules;
              maxSub && maxSub->sub;
              ++maxSub, ++k) {
            fprintf(latFile, "[%lu,%d]", (unsigned long)maxSub->sub->id + 1, maxSub->isoType + 1);
            if (maxSub[1].sub) {
               fprintf(latFile, ",");
               if (k % 10 == 9) { fprintf(latFile, "\n"); }
            }
         }
         if (i < nsub - 1) {
            fprintf(latFile, "]],\n");
         }
         else {
            fprintf(latFile, "]]\n");
         }
      }
      fprintf(latFile, "];\n");

      fclose(latFile);

      // Write the .gra file
      FILE* graFile = openTextOutputFile(".gra");
      fprintf(graFile, "%d\n", nsub);
      for (i = 0; i < nsub; ++i) {

         fputc(sub[i]->isMountain ? 'm' : '.', graFile);
         fputc(sub[i]->radicalLayer > 0 ? 'r' : '.', graFile);
         fputc(sub[i]->socleLayer > 0 ? 's' : '.', graFile);
         const MaxSubmodule_t* lp = sub[i]->maxSubmodules;
         for (k = 0; lp && lp->sub; ++lp, ++k) {}
         fprintf(graFile, " %2d", k);
         for (lp = sub[i]->maxSubmodules; lp && lp->sub; ++lp) {
            fprintf(graFile, " %lu %d", (unsigned long) lp->sub->id, lp->isoType);
         }
         fprintf(graFile, "\n");
      }
      fclose(graFile);
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Test if irreducible constituent #i and #k belong to the same block.
/// Actually, we check only if there is any mountain of constituent i contained in any mountain of
/// constituent k and vice versa.

static int sameblock(int i, int k)
{
   for (size_t ii = firstm[i]; ii < firstm[i + 1]; ++ii) {
      for (size_t kk = firstm[k]; kk < firstm[k + 1]; ++kk) {
         if (bsTest(xsubof[ii], kk)) { return 1; }
         if (bsTest(xsubof[kk], ii)) { return 1; }
      }
   }
   return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Builds the next block. Returns 1 on success or 0 if no more constituents remain.

static int nextblock()
{
    int i, k;

    ++blockNumber;
    for (i = 0; i < LI.nCf && done[i]; ++i);
    if (i >= LI.nCf) return 0;

    // If -b was not used, build a single block containing all irreducibles.
    if (!opt_b)
    {
	blockSize = LI.nCf;
	for (i = 0; i < LI.nCf; ++i)
	{
	    blockMember[i] = i;
	    done[i] = 1;
	}
	return 1;
    }

    // Otherwise, make the next block
    MTX_LOGD("---\nMaking block %d",blockNumber);
    done[i] = 1;
    blockSize = 1;
    blockMember[0] = i;
    i = 0;
    while (i < blockSize)
    {
	for (k = 0; k < LI.nCf; ++k)
    	    if (!done[k] && sameblock(blockMember[i],k))
    	    {
	        done[k] = 1;
	        blockMember[blockSize++] = k;
	    }
	++i;
    }

    // Sort block
    MTX_LOG2("Sorting block (size=%lu)", (unsigned long) blockSize);
    for (i = 0; i < blockSize; ++i) {
	for (k = i+1; k < blockSize; ++k)
	{
	    if (blockMember[i] > blockMember[k])
	    {
		int tmp = blockMember[i];
		blockMember[i] = blockMember[k];
		blockMember[k] = tmp;
	    }
	}
    }
    MTX_XLOGI(sb) {
       sbPrintf(sb, "Block %d: ",blockNumber);
	for (i = 0; i < blockSize; ++i)
	    sbPrintf(sb, " %s%s",LI.BaseName,latCfName(&LI,blockMember[i]));
    }
    return 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void clearHashTable()
{
   memset(hashTable, 0, sizeof(hashTable));
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static size_t hashKey(BitString_t *bs)
{
   uint32_t h1 = 0x12345678;
   uint32_t h2 = 0x33775588;
   hashLittle2(bs->data, bs->size / 8, &h1, &h2);
   return h1 % HASH_SIZE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Checks whether the given submodule is new. If yes, the submodule is added to the list.

static int tryAddSubmodule(BitString_t *bs, int generation)
{
   ++nadd;
   static uint64_t progressTimer = 0;
   if (sysTimeout(&progressTimer, 5)) {
      MTX_LOGD("Generation %d: %d candidates, %d new...", generation, nadd, nsub - lastGenEnd);
   }

   const size_t key = hashKey(bs);
   for (Submodule_t* item = hashTable[key]; item != NULL; item = item->htNext) {
      if (bsCompare(item->bs, bs) == 0)
         return 0;
   }
   if (nsub >= MAXNSUB) {
      mtxAbort(MTX_HERE, "Too many submodules (> %d)", MAXNSUB);
   }
   
   Submodule_t* item = ALLOC(Submodule_t);
   item->bs = bsAlloc(bnmount);
   item->dimension = 0;
   item->maxSubmodules = NULL;
   item->isMountain = 0;
   item->socleLayer = -1;
   item->radicalLayer = -1;
   bsCopy(item->bs, bs);
   item->htNext = hashTable[key];
   item->seq = nsub;
   item->id = nsub; // will be reset after sort
   item->generation = generation;
   hashTable[key] = item;
   sub[nsub++] = item;
   return 1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void initBlock()
{
    int row, col;

    // Determine the number of mountains in this block
    bnmount = 0;
    for (int i = 0; i < blockSize; ++i)
	bnmount += LI.Cf[blockMember[i]].nmount;

    // Build the incidence matrix
    MTX_LOGI("Building incidence matrix");
    fflush(stdout);
    for (int i = 0; i < bnmount; ++i)
    {
	bsubof[i] = bsAlloc(bnmount);
	bsupof[i] = bsAlloc(bnmount);
    }
    row = 0;
    for (int i = 0; i < blockSize; ++i)
    {
        for (int ii = firstm[blockMember[i]]; ii < firstm[blockMember[i]+1]; ++ii)
	{
	    col = 0;
	    for (int k = 0; k < blockSize; ++k)
	    {
		for (int kk=firstm[blockMember[k]]; kk<firstm[blockMember[k]+1]; ++kk)
		{
		    if (bsTest(xsubof[ii],kk))
		    {
			bsSet(bsubof[row],col);
		        bsSet(bsupof[col],row);
		    }
		    ++col;
		}
	    }
	    bmdim[row] = xmdim[ii];
	    ++row;
	}
    }

    // Build the dotted lines for this block
    MTX_LOGI("Building dotted lines");
    fflush(stdout);
    bndotl = 0;
    for (int i = 0; i < blockSize; ++i)
    {
        for (int ii = firstdl[blockMember[i]]; ii < firstdl[blockMember[i]+1]; ++ii)
	{
	    bdotl[bndotl] = bsAlloc(bnmount);
	    bdlspan[bndotl] = bsAlloc(bnmount);
	    col = 0;
	    for (int k = 0; k < blockSize; ++k)
	    {
		for (int kk=firstm[blockMember[k]]; kk<firstm[blockMember[k]+1]; ++kk)
		{
		    if (bsTest(xdotl[ii],kk))
		    {
			bsOr(bdlspan[bndotl],bsupof[col]);
			bsSet(bdotl[bndotl],col);
		    }
		    ++col;
		}
	    }
	    ++bndotl;
	}
    }

    // Initialize global variables
    nsub = 0;
    clearHashTable();
    lastGenEnd = 0;
    lastGenBegin = 0;
    // Add generation 0 (null module)
    tryAddSubmodule(bsAlloc(bnmount), 0);
    lastGenEnd = nsub;
    generation = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Clean up after each block

static void cleanupBlock()
{
    int i;

    for (i = 0; i < bnmount; ++i)
    {
	free(bsubof[i]);
	free(bsupof[i]);
    }
    for (i = 0; i < bndotl; ++i)
    {
	free(bdotl[i]);
    }
    if (opt_o & O_SUBMODULES)
    {
        for (i = 0; i < nsub; ++i)
        {
	    bsFree(sub[i]->bs);
	    sysFree(sub[i]->maxSubmodules);
            memset(sub[i], 0, sizeof(Submodule_t));
            sysFree(sub[i]);
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/// Make next generation (submodules generated by n+1 mountains)

static void nextgen()
{
   ++generation;
   const int begin = nsub;
   BitString_t* x = bsAlloc(bnmount);
   for (int i = lastGenBegin; i < begin; ++i) {
      for (int k = 0; k < bnmount; ++k) {
         if (bsTest(sub[i]->bs, k)) {
            continue;
         }
         bsCopy(x, sub[i]->bs);
         extend(x, k, 0);
         tryAddSubmodule(x, generation);
      }
   }

   lastGenBegin = begin;
   lastGenEnd = nsub;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static int setFormatFlags(const char *c, int set)
{
    static int FirstTime = 1;
    if (FirstTime)
    {
	FirstTime = 0;
	opt_o = set ? 0 : O_ALL;
    }
    for (; *c != 0; ++c)
    {
	int flag = 0;
	switch (*c)
	{
	    case 'm': flag = O_MOUNTAINS; break;
	    case 's': flag = O_SUBMODULES; break;
	    case 'd': flag = O_DOTTEDLINES; break;
	    case 'e': flag = O_EXTFILES; break;
	    case 'r': flag = O_RADICAL; break;
	    case 'o': flag = O_SOCLE; break;
	    case 'i': flag = O_INCIDENCES; break;
	    default: 
		mtxAbort(MTX_HERE,"Unknown format flag '%c'",*c);
		return -1;
	}
	if (set)
	    opt_o |= flag;
	else
	    opt_o &= ~flag;
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static int ParseCommandLine()
{
    const char *c;

    opt_G = appGetOption(App,"-G --gap");
//    if (opt_G) 
//	MtxMessageLevel = -100;
    opt_b = appGetOption(App,"-b --blocks");
    if ((c = appGetTextOption(App,"-o --output",NULL)) != NULL)
    {
	if (setFormatFlags(c,1) != 0)
	    return -1;
    }
    if ((c = appGetTextOption(App,"-n --no-output",NULL)) != NULL)
    {
	if (setFormatFlags(c,0) != 0)
	    return -1;
    }
    if (appGetArguments(App,1,1) != 1)
	return -1;
    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////

static void calculateCfInfo()
{
    int i;

    // Set firstm and firstdl
    firstm[0] = 0;
    firstdl[0] = 0;
    for (i = 0; i < LI.nCf; ++i)
    {
	firstm[i+1] = firstm[i] + LI.Cf[i].nmount;
	firstdl[i+1] = firstdl[i] + LI.Cf[i].ndotl;
    }

    // Initialize done[]
    for (i = 0; i < LI.nCf; ++i) done[i] = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static int Init(int argc, char **argv)
{
    if ((App = appAlloc(&AppInfo,argc,argv)) == NULL)
	return -1;
    if (ParseCommandLine() != 0)
	return -1;
    MTX_LOGI("\n*** CALCULATE ALL SUBMODULES ***");
    init(App->argV[0]);
    calculateCfInfo();
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
    if (Init(argc,argv) != 0)
    {
	mtxAbort(MTX_HERE,"Initialization failed");
	return -1;
    }

    while (nextblock())
    {
	initBlock();

	if (opt_o & O_SUBMODULES)
	{
	    while (1)
	    {
		nadd = 0;
		nextgen();
                if (lastGenEnd == lastGenBegin) break;
		MTX_LOGI("Generation %d: %lu candidates, %lu new",
		    generation, (unsigned long) nadd, (unsigned long)(lastGenEnd - lastGenBegin));
	    }
	    finishBlock();
	}
	else
	    MTX_LOGI("Submodules not calculated");

	writeresult();
	cleanupBlock();
    }
    appFree(App);
    return 0;
}



/**
@page prog_mksub mksub - Find Submodules

@section mksub_syntax Command Line
<pre>
mksub @em Options [-Gb] [-o @em Format] [-n @em Format] @em Name
</pre>

@par @em Options
  Standard options, see @ref prog_stdopts
@par -G
  Produce output in GAP format.
@par -b
  Find blocks (see description).
@par -o @em Format
  Include the selected parts in the output (see description).
@par -n @em Format
  Exclude the selected parts from the output (see description).
@par @em Name
  Name of the representation.

@section mksub_inp Input Files
@par @em Name.cfinfo
  Constituent info file.
@par @em Name.inc
  Incidence matrix generated by @ref prog_mkinc "mkinc".
@par @em Name.dot
  Dotted-lines generated by @ref prog_mkdotl "mkdotl".
@par @em Name.mnt
  Mountain dimensions.

@section mksub_out Output Files
@par @em Name.cfinfo
  Constituent info file.
@par @em Name.out
  Submodule lattice.
@par @em Name.lat
  Incidence matrix of the submodules (GAP).
@par @em Name.gra
  Submodule lattice for @ref prog_mkgraph "mkgraph".

@section mksub_desc Description

The MKSUB program is part of the @ref sec_progs_lattice "Submodule Lattice Package".
MKSUB calculates the submodule lattice using the output
generated by @ref prog_mkinc "mkinc" and @ref prog_mkdotl "mkdotl".
In this final step no matrix operations are involved.
Instead the program works with bit strings representing the incidences
and dotted-lines.
The lattice may be decomposed into blocks using the "-b" option (see below).

Submodules are calculated generation by generation, the first
generation consisting of all submodules generated by one 
local submodule. In the n-th generation all submodules generated
by a submodule of generation n plus one local submodule are
calculated. If no more submodules appear, the algorithm terminates.

Output is written to three text files and one binary file. The first
file, @em Name.out, contains a list of irreducible constituents, 
the incidence matrix, the dimensions of all local submodules, a list of
dotted lines, a list of all submodules, the radical and socle series,
and a list of all mountains, i.e., local submodules.
The second output file is @em Name.lat. It contains the lattice as 
a list in GAP format. This list contains, for each
submodule, its dimension, maximal submodules and isomorphism types
of simple factors are given (see the example below). The third output 
file, @em Name.gra, contains a description
of the submodule lattice together with some additional information. 
This file is read by the @ref prog_mkgraph "mkgraph" program to produce a graphical 
representation of the lattice. A further output file, @em Name.sub 
contains the submodule lattice in binary format. This file is read by
the @ref prog_genmod "genmod" program.

@subsection blk Blocks
If the "-b" option is used, @b mksub tries to decompose the lattice
into blocks. By definition, a block is a set of one or more
composition factors which is closed under incidences of local
submodules. For a decomposition into blocks to be possible, there 
must be direct summands with no common irreducible constituent.
If a decomposition exists, the whole lattice can be reconstructed
from its blocks by forming direct sums.

Output files are created separately for each block, and a number
is appended to the name. For example, if the representation is
called "psl211" and the lattice decomposes into 3 blocks,
@b mksub creates 9 output files:
<pre>
psl211.out.1 psl211.lat.1 psl211.gra.1
psl211.out.2 psl211.lat.2 psl211.gra.2
psl211.out.3 psl211.lat.3 psl211.gra.3
</pre>


@subsection of Changing the Output Format

The default output as shown above may be changed by using the
"-o" option. @em Format is any combination of "m", "d", "i", "e", "s", "r", "s".
Each letter corresponds to a certain piece of output:
@par m
  Mountains.
@par d
  Dotted lines.
@par i
  Incidence matrix.
@par e
  ".lat" and ".gra" files.
@par s
  Submodules.
@par r
  Radical series.
@par o
  Socle series.

**/

// vim:fileencoding=utf8:sw=3:ts=8:et:cin
